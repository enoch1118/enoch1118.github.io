---
layout: posts
title: CS-운영체제(2)-프로세스
categories:
- cs
  
tags:
- cs
- 프로세스
- 운용체제
---

### 프로세스의 개념

* 프로그램의 실행.
프로그램이 어디까지 실행되었는지, 프로세스의 내용이 어디까지 쌓아놓았는지
를 말하는것을 프로세스의 문맥이라고 한다.
  
cpu -> PC,register
메모리-> code data stack

PCB(process contro BLock) 는 운용체제 가 할당하는 값=> cpu 사용량, 어떻게 사용하는지. 
kernel stack -> 여러프로세스가공유하는, 시스템콜 

> 왜 이런 지식이 필요한가? 현대 시스템은 시분할이기때문에, 지금 실행하고있는 프로세스의 문맥을 백업해야지만,
> 인터럽트가 발생해도 다시 진행할수있기때문에.
> 

* 프로세스의 상태

Running:CPU를 잡고 instruction을 수행중일때
Ready:다른 조건을 다만족하고, CPU를 기다리는 상태
Blocked(wait,sleep):CPU를 주어도 수행 불가능한상태,event(I/O)가 만족되지않은상태//파일읽기
//공유 데이터를 접근중일때도 블락 상태가 될수있다.
suspended(stopen):외부적으로 정지된상태, 프로세스가 통째로 디스크에 swap out 된다. 외부에서 resume 해주어야 된다.


New:프로세스가 생성중일때
Terminated:수행(execution)이 끝난상태

프로세스의 상태는 운영체제의 커널에서 자신의 데이터 영역에서 관리한다.


* PCB
    * os가 관리하는 정보
> 프로세스 상태,아이디,스케줄링 정보,우선순위
> <br> PC,registers < CPU
> <br> Code,data,stack < memory
> <br> 파일관련 

* 문맥교환

CPU가 프로세스에서 다른프로세스로 넘겨주는과정.
먼저 내어주는 프로세스의 상태를 해당 프로세스 PCB에 저장.
다른프로세스의 PCB를 가져옴


시스템콜이나 인터럽트마다 반드시 문맥교환이 일어나지는 않음
시스템콜은 사용자 프로세스로부터 OS로 CPU가 넘어가는 것이지, A로부터 B로 넘어가야지 일어남.
A에서 A로 다시 돌아오는경우 문맥교환이 일부 일어나긴하지만 A에서 B로 넘어가는 것보단 부담이 적다.(캐쉬 메모리 플러시)
timer interrupt에 경우 무조건 문맥교환이 일어남
I/O작업 역시도 문맥교환이 일어남


* 프로세스를 스케줄링 하기 위한 큐
> job queue 현재 시스템에 모든프로세스의 집합
> ready queue 메모리 내에 있는 프로세스 집합
> device queue I/O처리를 기다리는 프로세스 집합

* 스케줄러
> 롱텀스케줄러 장기수케줄러 잡 스케줄러
> > <br>시작 프로세스중 레디큐로 보낼지 결정
> > <br>프로세스에 자원을 주는 문제
> > <br>degree of multiprogramming ㅔㅈ어
> > <br>타임 쉐어링 시스템에는 장기 스케줄러가 없음
> <br>단기 스케줄러 cpu 스케줄러 숏텀 스케줄러
> > 어떤프로세스를 다음에 실행할지 결정
> > <br>프로세스에 cpu를 주는 문제
> > <br>빨라야한다
> <br> 미드텀 스케줄러 스와퍼 중기 스케줄러
> > <br> 여유공간을위해 메모리를 디스크로 쫒아냄
> > <br> 프로세스에서 메모리를 뺏는문제
> > <br> degree of multiprogramming 제어 

