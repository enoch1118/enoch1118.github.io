---
layout: posts
title: CS-운영체제(3)-프로세스관리2
categories:
- cs
  
tags:
- cs
- 프로세스관리
- 운용체제
---

####부모프로세스와 자식프로세스의 자원공유
* copy on write COW
  

바로 자식 프로세스가 자원을 할당받는것이 아니라 부모와 다른 내용이 생성 되었을경우
  자신만의 자원을 할당 받는다. (코드,데이터,스택)

* Fork() 시스템콜
  

부모 프로세스가 새로운 프로세스를 생성 하게 해달라고 운영체제에게 콜을 보내는것.

* exec() 시스템콜
  

하나의 프로세스를 다른 프로세스로 만들어내는것.

* wait()
  

자식이 종료될때까지(block)

자식이 종료되면 (ready)

- exit()

프로세스의 종료.
자발적 종료 프로그램이 스스로 종료되고  싶을때 
비자발적인 종료는 부모프로셋스가 자식프로세스를 종료일때 
사람이 자발적으로 키보드의 kill break 등을 친경우 
부모가 종료되었을경우 자식들을 먼저 종료시킨다음에 종료되어진다.

- 프로세스간의 협력

독립적 프로세스:프로세스는 각자 독자적 공간을 가지고있으므로 수행에 영향을 미치지못함.
협력 프로세스:프로세스의 협력 메커니즘 통해 하나의 프로세스에 다른 프로세스가 영향을 미칠수있음

- 협력 메커니즘
  + 메세지 패싱 : 운용체제의 커널을 통한 전달.
    + direct:통신하려는 프로세스의 이름을 명시적으로 표시
    + indirecct:mailbox 혹은 port를 통해 메세지를 전달.(아무나)
  + shared memory:서로 다른 프로세스간에 주소공간을 공유하게 만드는 방법.
    물리적인 메모리상에서 공유 메모리 영역을 만들어낸다
    이것도 역시 커널의 시스템콜을 통해서 메모리를 매핑해야한다.
    커널이 한번만 허락해주면 메모리끼리 작업할수있지만.
    두개의 프로세스 간 상당히 신뢰하는 관계여야한다.
  + thread:사실상 다른 프로세스가아니라 한개의 프로세스에서 분리된 공간을 가지는것이기때문에
    공유하는 주소공간이 있으므로 당연히 협력이 가능하다.



### CPU 스케줄링

* cpu burst,I/O burst

사람이 작업을 하는 프로그램은 통상적으로 i/o 버스트의 길이가 길어지지만. 과학 계산용 프로그램은 cpu
버스트의 길이가 길어진다.

- cpu 스케줄링이 필요한 이유

i/o버스트가 긴 프로그램에경우 i/o가 너무길다면 효율성이 부족하고 사람이 느끼기에 매우 답답해질수도있다.

- cpu scheduler: ready 상태의 프로세스 중에서 이번에 cpu를 줄 프로세스를 고른다.
  (운영체제안에있는 코드)
- dispatcher: 스케줄러에게 선택된 프로세스에게 제어권을 넘기는 코드

- cpu 스케줄링이 필요한경우
  - running->blocked io 요청 시스템콜 //자진반납
  - running->ready 할당시간만료 timer  interrupt //강제반납
  - blocked->ready i/o완료후 인터럽트(바로 주지는 않음) //강제반납
  - terminate //자진반납

preemptive(강제) nonpreeemptive(자진반납)